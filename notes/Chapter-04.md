# 对象和类

`OOP(object-oriented programming)`，使用对象（类的实例）进行程序设计。特征：

1. 抽象
2. 多态
3. 继承
4. 封装

类的组成：

1. 属性（数据域）
2. 函数（定义行为）
3. 两种特殊的函数：构造函数`ctor`（创建对象调用）和析构函数`dtor`（对象销毁时调用）

## 构造函数

1. 创建对象时调用
2. 与类同名
3. 无返回值
4. 可重载
5. 可不带参数
6. 可以不写声明函数，不明确的声明构造函数，编译器会提供一个空函数体的默认构造函数（无参数构造函数）

对象指针访问对象的数据和函数，如何操作？

# 对象访问和匿名(anonymous)对象

类是一种数据类型，和 `int` 同一个级别。前者定义对象，后者定义变量。

代表类型的名字首字母大写，其他字母大小写混合。

## 成员(memberwise)拷贝

默认情况下，每一个数据域成员全部被拷贝。

## 匿名对象

创建一个只用一次的对象，不命名的对象是匿名对象。

## 局部类

类声明在函数中

## 嵌套类

类中的类。（不推荐）

# 声明与实现分离

类声明命和实现分开。只涉及函数，不涉及数据域。

- `.h` 类声明，描述类的结构
- `.cpp` 类的实现，描述类的方法
- 类中定义内联函数，无需写`inline`关键字

编译方式：`g++ main.cpp class.cpp -o main.exe`

# 避免头文件被多次包含

`C++` 预处理指令，保证头文件只被包含/编译一次。

```C++
// 刚开始宏没定义
// 下次再包含，宏已经定义，跳过
#ifndef NY_HEADER_FILE_H
// 定义宏和内容
#define MY_HEADER_FILE_H
// 内容
#endif 
```

编译指令，只编译一次
```C++
#pragma once
```

`C++11`中运算符：
```C++
// 建议不加分号
_Pragma("once")
```

# 对象指针和动态对象

函数中生命的对象存在于栈，由编译器自动创建和释放，内存由编译器帮我们管理，函数返回，对象被销毁。

在堆上创建对象，程序员控制对象的生存期。

# 对象数组

- `Circle c[10] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};` 作为对象数组
- `auto c4 = new Circle[3]{1.2, 2.3, 3.4};` 是数组指针，两者不一样

# 对象作为参数

## 参数传递

1. 值传递
```C++
// Pass by value
void print( Circle c ) {
  /* … */
}
int main() {
  Circle myCircle(5.0);
  print( myCircle );
}
```
2. 引用传递
```C++
void print( Circle& c ) {
  /* … */
}
int main() {
  Circle myCircle(5.0);
  print( myCircle );
}
```
3. 指针传递
```C++
void print( Circle* c ) {
  /* … */
}
int main() {
  Circle myCircle(5.0);
  print( &myCircle );
}
```

## 对象作为参数返回

1. 返回对象
```C++
// class Object { ... };
Object f ( /*函数形参*/ ){
  // Do something
  return Object(args);
}
// main() {
Object o = f ( /*实参*/ );
f( /*实参*/ ).memberFunction();
```
2. 返回对象指针（不要在函数外部删除函数内部创建的指针，应该由函数外创建，函数内修改，函数外删除）
```C++
// class Object { ... };
Object* f ( /*函数形参*/ ){
  Object* o = new Object(args) // 这是“邪恶”的用法，不要这样做
  // Do something
  return o;
}
// main() {
Object* o = f ( /*实参*/ );
f( /*实参*/ )->memberFunction();
// 记得要delete o
```
允许的用法
```C++
// class Object { ... };
Object* f ( Object* p, /*其它形参*/ ){
  // Do something
  return p;
}
// main() {
Object* o = f ( /*实参*/ );
// 不应该delete o
```
3. 返回对象引用（考虑对象的生存周期
```C++
// class Object { ... };
Object& f ( /*函数形参*/ ){
  Object o {args};
  // Do something
  return o;  //这是邪恶的用法
}
```
可行的用法1
```C++
// class Object { ... };
class X {
  Object o;
  Object f( /*实参*/ ){
    // Do something
    return o;
  }
}
```
可行的用法2
```C++
// class Object { ... };
Object& f ( Object& p, /*其它形参*/ ){
  // Do something
  return p;
}
// main() {
auto& o = f ( /*实参*/ );
f( /*实参*/ ).memberFunction();
```
4. 尽可能使用 const 修饰函数返回值类型和参数

C++中有意义的是：传值和传引用。

# 封装与抽象

数据域封装，数据和操作数据的函数放在一起，形成一个类。数据在共有域，可能被类外的方法篡改。数据放在`private`，被类内的方法访问，也就是封装，方法放在`public`。

`bool`类型的`get`函数开头是 `is`。

- 抽象：专注于感兴趣的细节，去除不需要的细节。
- 封装：一种限制直接访问类内组成对象的语言机制，一种实现数据和函数绑定的语言块。

# 成员作用域与this指针

## 同名屏蔽

类中函数可以访问类内成员，数据域与函数可按任意顺序声明。

同名屏蔽：函数中的局部变量和类中的变量同名，局部变量优先级高。同名数据域在函数内被屏蔽。

尽可能避免，万一重名后，在局部变量后面加下划线。私有类成员变量不建议加下划线。

## this 指针

不需声明不需复制的特殊内建指针，指向当前对象的指针，引用当前函数的调用对象，不能修改指向另外的对象。

# 类成员就地初始化

非静态成员可以在声明的时候初始化。

类成员初始化时，数组类型不能自动推断大小，需要指明数组长度。

# 构造函数初始化列表

主要作用是初始化类中的基础数据类型的数据成员。需要构造函数初始化列表的原因：
一个类里面的内嵌对象，在构造函数执行前就构造完成。