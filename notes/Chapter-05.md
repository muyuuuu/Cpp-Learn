# 常量表达式

在编译的时候就能计算结果的一个表达式，由编译器执行得到结果。`const` 是运行期的常量，不是编译期的常量。没办法作为数组的大小去定义数组：

```C++
const int a;
a++;   // 错误 a 只能读
std::array<int, a> a1;

int a;
a = 3;
sta::array<int, a> a2;  // 错误，a不是常量表达式
```

`const`可以定义编译期常量，也可以定义运行期常量：

```C++
const int a = 1; // 编译期常量
const int a = n; // 运行期常量
```

使用编译期常量的原因是，让编译期优化代码提升性能。

# 断言

检测的语句，假设成立，断言没事；假设不成立，断言中断程序的执行。用于检查逻辑是否有错误。`#include<cassert>`，以调试模式编译程序，调试模式传入的编译参数不一样，且不会进行优化。

某些情况是预期的，用错误处理；某些情况不能发生，使用断言，不要放到程序的发行版中，而是找到错误后保证程序正确。

## 静态断言

`static_assert([], [])`第一个参数是布尔类型的常量表达式，不能有变量，第二个参数是断言失败时的警告信息。

# 声明与定义

声明：引入标志符，来描述类型，无论是类型，对象还是函数。编译期需要声明，知道声明后，知道某个地方有这个东西，并记住，在之后识别出来。

定义：实例化或实现标志符，链接器需要。将不同文件编译得到的目标文件汇总到一起。对标志符的引用链接到标志符对应的实体。

区别：
- 定义有时候可以取代声明，反之不可以；
- 标志符可以多次声明，只能定义一次；
- 定义通常伴随着，编译器为标志符分配内存，告诉编译器标志符长成啥样。声明不涉及分配内存，只是告诉编译器某个地方有这个东西；

# 委托构造

构造函数委托别的构造函数来实现某些功能，被委托的函数放在委托函数的初始化列表的位置。避免出现递归调用的委托函数，防止函数调用之间出现环形。

好处：逻辑清晰一些。

# 不可变对象和类

- 所有数据域为私有属性
- 没有更改器函数
- 没有返回指针的对象访问器

对象创建后，内容不可改变，除非通过成员拷贝。类图中，`-`表示私有成员，`+`表示共有成员。

如果一个类，所有数据域为私有属性，且无更改器函数。类的成员是指针成员时，指针指向私有成员，调用指针，会修改数据值，不再是不可变对象。

变量混合大小写，小写字母开头。

# 静态成员

声明静态成员不绑定在类的实例中，无需创建对象即可访问。具有静态存储期，对象的存储在程序开始时分配，程序结束回收；只存在对象的一个实例，不管对象创建了多少个类，静态成员只有一个；静态存储器对象未明确初始化，会自动零初始化。

- `constexpr` 类型的静态成员必须在类中声明并初始化，不能在类外定义
- `inline` 类型或 `const int` 类型可以在类中声明并初始化
- 其它在类外定义并初始化，不能带 `static` 关键字，大部分不会出错

```C++
class A {
public:
    A(int a=0){
        x = a;
    }
    static void f1(){
    // y++; 对 
    // x++ 错 静态函数对应静态成员
    };
private:
    int x;
    static int y;
};
```

# 析构函数

和构造函数相对应，对象销毁时自动调用，没有返回值，参数列表为空，不能重载。没有显示声明时，编译器自动创建，语法 `~C()=default`默认析构，`~C()=delete`不允许默认生成析构函数。

# 友元

为什么需要友元：私有成员无法从类的外部访问，打破私有保护，允许信任的函数去操作私有成员，打破了封装的特性，关键字是 `friend`。

# 拷贝构造函数

特殊的构造函数，根据已有的对象，创造另外的相同对象。用一个对象初始化另一个同类对象。语法：

```C++
Circle(Circle&);
Circle(const Circle&); // 拷贝构造函数不会被意外修改
```

编程标准：

```C++
Circle X{
public:
    // 拷贝构造函数的参数，之后所有参数带有默认值
    X(const X&, int a = 1);
}
X b(a, 0);
X c = b;
```

调用拷贝函数：
```C++
Circle c2(c1);
// 不是复赋值 是拷贝构造函数
Circle c2 = c1;
Circle c2{c1};
```

只有在定义时为拷贝构造，普通情况下 `obj1 = obj2` 是对象赋值。

## 隐式声明的拷贝构造

一般而言，程序员不写拷贝构造函数，编译器会自动生成一个。自动生成的拷贝构造函数就是隐式声明的拷贝构造函数。将被拷贝对象的数据域，一对一复制到新的对象中，不进行其他工作，若进行其他工作，需要自己编写拷贝构造函数。

# 深浅拷贝
由类中的指针类型成员引起

- 浅拷贝(`shallow copy`)：只拷贝指针成员的地址，不如拷贝指针指向的内容。
- 深拷贝(`copy`)：即拷贝非指针成员，也拷贝指针指向内容。

浅拷贝出现情况：
1. 创建新对象使用默认`default`拷贝构造函数
2. 为已有对象赋值使用默认赋值运算符

可能导致一些问题，修改一个变量会影响源头的变量。

深拷贝：
1. 重载默认赋值函数
2. 自己编写拷贝构造函数，拷贝指针所指的内容

# 字符串字面量

`C++11`中语法：`R"delimiter(raw_characters)delimiter"`。

`C++14`：重载 `""s` 运算符。

# 更多编码规范

1. 只要能增强可读性，编码可不必遵循编程风格指南
2. 有很好的个人理由的话，可以不遵守规范
3. 变量尽力写在前面，声明处初始化
4. 建议缩进两个空格，防止换行，其实四个也行
5. 循环语句的布局，大括号不换行等
6. 函数的定义建议大括号换行
7. 保留字后面有空格，冒号前后有空格，for语句分号后有空格

# 结构化绑定声明

一个声明语句，声明一些标志符并初始化。绑定数组、对象、结构体，元祖等。将指定的一些名字绑定到初始化器的子对象或元素上，如`int x{5}`。

`cv-auto (const volatile)`，`&`左值引用，`&&`右值引用。

## 原生数组的结构化绑定声明

将一些标志符，绑定到数组元素中。初始化器为数组类型，标志符列表和数组元素对应。

- 标志符数量和数组元素数量相等
- 标志符类型和数组类型保持一致

## 对象数据成员的结构化绑定声明

将标志符列表中的名字绑定到类/结构体等**非静态数据成员**上。
- 数据成员是共有的
- 数量和类型一致

