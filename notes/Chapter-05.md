# 常量表达式

在编译的时候就能计算结果的一个表达式，由编译器执行得到结果。`const` 是运行期的常量，不是编译期的常量。没办法作为数组的大小去定义数组：

```C++
const int a;
a++;   // 错误 a 只能读
std::array<int, a> a1;

int a;
a = 3;
sta::array<int, a> a2;  // 错误，a不是常量表达式
```

`const`可以定义编译期常量，也可以定义运行期常量：

```C++
const int a = 1; // 编译期常量
const int a = n; // 运行期常量
```

使用编译期常量的原因是，让编译期优化代码提升性能。

# 断言

检测的语句，假设成立，断言没事；假设不成立，断言中断程序的执行。用于检查逻辑是否有错误。`#include<cassert>`，以调试模式编译程序，调试模式传入的编译参数不一样，且不会进行优化。

某些情况是预期的，用错误处理；某些情况不能发生，使用断言，不要放到程序的发行版中，而是找到错误后保证程序正确。

## 静态断言

`static_assert([], [])`第一个参数是布尔类型的常量表达式，不能有变量，第二个参数是断言失败时的警告信息。

# 声明与定义

声明：引入标志符，来描述类型，无论是类型，对象还是函数。编译期需要声明，知道声明后，知道某个地方有这个东西，并记住，在之后识别出来。

定义：实例化或实现标志符，链接器需要。将不同文件编译得到的目标文件汇总到一起。对标志符的引用链接到标志符对应的实体。

区别：
- 定义有时候可以取代声明，反之不可以；
- 标志符可以多次声明，只能定义一次；
- 定义通常伴随着，编译器为标志符分配内存，告诉编译器标志符长成啥样。声明不涉及分配内存，只是告诉编译器某个地方有这个东西；

# 委托构造

构造函数委托别的构造函数来实现某些功能，被委托的函数放在委托函数的初始化列表的位置。避免出现递归调用的委托函数，防止函数调用之间出现环形。

好处：逻辑清晰一些。

# 不可变对象和类

- 所有数据域为私有属性
- 没有更改器函数
- 没有返回指针的对象访问器

对象创建后，内容不可改变，除非通过成员拷贝。类图中，`-`表示私有成员，`+`表示共有成员。

如果一个类，所有数据域为私有属性，且无更改器函数。类的成员是指针成员时，指针指向私有成员，调用指针，会修改数据值，不再是不可变对象。

变量混合大小写，小写字母开头。

# 静态成员

声明静态成员不绑定在类的实例中，无需创建对象即可访问。具有静态存储期，对象的存储在程序开始时分配，程序结束回收；只存在对象的一个实例，不管对象创建了多少个类，静态成员只有一个；静态存储器对象未明确初始化，会自动零初始化。

- `constexpr` 类型的静态成员必须在类中声明并初始化，不能在类外定义
- `inline` 类型或 `const int` 类型可以在类中声明并初始化
- 其它在类外定义并初始化，不能带 `static` 关键字，大部分不会出错

```C++
class A {
public:
    A(int a=0){
        x = a;
    }
    static void f1(){
    // y++; 对 
    // x++ 错 静态函数对应静态成员
    };
private:
    int x;
    static int y;
};
```