# 引用

函数传参、指针相关，是另一个变量的别名，如外号。

对引用做的读写操作，作用在原来变量上，附着在存在的变量，所以引用在定义的时候就必须被初始化，否则引用不存在。

## 引用传参

引用作为函数形式参数，调用传普通变量。与普通参数的不同：

>被调函数中，改变引用参数值，会改变实际参数的值。

# 空指针

在 `C++11` 后，空指针是一个确定的东西，空指针作为保留字 `nullptr`。

# 动态内存管理

分配`new`与释放`delete`，分配不释放，会导致内存浪费，消耗大量内存。

申请成功，返回指定类型的地址；失败，抛出异常，返回空指针。

# 数据类型转换

## 布尔

布尔变量的前缀使用`is, has, can, should`，如`isMyBook`。

- 关系运算：`a == 3`
- 逻辑运算：`a && b`

1. 0 和 `false` 能相互转化
2. `true` 能转化为 1
3. 非零整数能转化为 `true`
4. `'a'` 转换为 `true`


## 列表初始化

之前：

```C++
int x = 0;
int y(2);
char c('a');

int arr[] = {1, 2, 3};
char s[] = "hello";
```

之后（列表初始化，统一初始化方法），使用背景：
1. 尽量使用列表初始化；
2. 因为不允许窄化，不允许丢失数据精度的隐式类型转化，如`int x = {1.2}`

## 类型转换

1. 隐式：没有明确声明。**写显式类型转换，不要依赖编译器提供的隐式类型转换。**
2. 显式：代码中有明确的转换语句和类型，`(int)2.5`

# 类型系统增强

只要写程序，就会涉及到类型。

## 计算机程序构造块

1. 不同大小粒度的计算机程序组成部分
2. 包括变量、表达式、函数等

## 类型系统

是将类型属性指定给不同计算机程序构造块的规则集（一些规范，强制要求，用于数据结构和组件等）。

使用原因：减少`bug`，定义了程序块的接口，检查多个块是否以一致的方法连接在一起。

1. 静态类型：在编译期发生 （`C++`）
2. 动态类型：在运行期发生 （`python`）
3. 混合类型：同时存在

## 自动类型推导

自动为变量选择匹配类型，不仅仅为省去写数据类型的方便。限制：
1. 在定义的时候初始化，用初始值来推断类型
2. 定义在序列中的变量必须同一类型
3. 初始化表达值里面有引用或`const`，去除引用或`const`语义
4. `auto& `则表达引用或`const`语义
5. 初始化为数组时，`auto`推导类型为指针
6. 若`auto& `，推导类型为数组类型

作为函数的返回值类型和参数类型。**尽量使用`auto`：**

保证代码的正确性、健壮性、可维护性，保证在声明时初始化，推断变量的类型。`auto z = int(3.0)` 强制类型转换。

## decltype

利用已知的类型声明新的变量。在编译时期推导一个表达式的类型，不用初始化。

# 简化的 C++ 内存模型

指针直接操作内存，其他语言没有。

1. 栈区：编译器自动分配释放，程序员不用关心。存储局部变量、形式参数等。
2. 堆区：程序员分配释放，不释放的话程序结束由系统回收，但完全依赖并不合适。
3. 全局区/静态区：程序开始到程序结束一直都存在，全局变量与静态变量的初始化。在 `main` 函数执行之前执行。
4. 常量区：存放所有的常量，内容不能被修改。强行修改会导致程序崩溃，防止后期造成更大的问题。

堆在低地址（从左到右，向高地址推进），栈在高地址（从右向左，向低地址推进）。然后堆、栈会共享一片区域，增加内存使用效率。

`char* str = "hello world";`，`str`位于栈区，`"hello world"`位于常量区。

`new char[8]`放在堆区。

数组的名字是数组首地址的别名，按照地址访问数组的值：`*(a + 2)`。