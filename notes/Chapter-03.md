# 引用

函数传参、指针相关，是另一个变量的别名，如外号。

对引用做的读写操作，作用在原来变量上，附着在存在的变量，所以引用在定义的时候就必须被初始化，否则引用不存在。

## 引用传参

引用作为函数形式参数，调用传普通变量。与普通参数的不同：

>被调函数中，改变引用参数值，会改变实际参数的值。

# 空指针

在 `C++11` 后，空指针是一个确定的东西，空指针作为保留字 `nullptr`。

# 动态内存管理

分配`new`与释放`delete`，分配不释放，会导致内存浪费，消耗大量内存。

申请成功，返回指定类型的地址；失败，抛出异常，返回空指针。

# 数据类型转换

## 布尔

布尔变量的前缀使用`is, has, can, should`，如`isMyBook`。

- 关系运算：`a == 3`
- 逻辑运算：`a && b`

1. 0 和 `false` 能相互转化
2. `true` 能转化为 1
3. 非零整数能转化为 `true`
4. `'a'` 转换为 `true`


## 列表初始化

之前：

```C++
int x = 0;
int y(2);
char c('a');

int arr[] = {1, 2, 3};
char s[] = "hello";
```

之后（列表初始化，统一初始化方法），使用背景：
1. 尽量使用列表初始化；
2. 因为不允许窄化，不允许丢失数据精度的隐式类型转化，如`int x = {1.2}`

## 类型转换

1. 隐式：没有明确声明。**写显式类型转换，不要依赖编译器提供的隐式类型转换。**
2. 显式：代码中有明确的转换语句和类型，`(int)2.5`

# 类型系统增强

只要写程序，就会涉及到类型。

## 计算机程序构造块

1. 不同大小粒度的计算机程序组成部分
2. 包括变量、表达式、函数等

## 类型系统

是将类型属性指定给不同计算机程序构造块的规则集（一些规范，强制要求，用于数据结构和组件等）。

使用原因：减少`bug`，定义了程序块的接口，检查多个块是否以一致的方法连接在一起。

1. 静态类型：在编译期发生 （`C++`）
2. 动态类型：在运行期发生 （`python`）
3. 混合类型：同时存在

## 自动类型推导

自动为变量选择匹配类型，不仅仅为省去写数据类型的方便。限制：
1. 在定义的时候初始化，用初始值来推断类型
2. 定义在序列中的变量必须同一类型
3. 初始化表达值里面有引用或`const`，去除引用或`const`语义
4. `auto& `则表达引用或`const`语义
5. 初始化为数组时，`auto`推导类型为指针
6. 若`auto& `，推导类型为数组类型

作为函数的返回值类型和参数类型。**尽量使用`auto`：**

保证代码的正确性、健壮性、可维护性，保证在声明时初始化，推断变量的类型。`auto z = int(3.0)` 强制类型转换。

## decltype

利用已知的类型声明新的变量。在编译时期推导一个表达式的类型，不用初始化。

# 简化的 C++ 内存模型

指针直接操作内存，其他语言没有。

1. 栈区：编译器自动分配释放，程序员不用关心。存储局部变量、形式参数等。
2. 堆区：程序员分配释放，不释放的话程序结束由系统回收，但完全依赖并不合适。
3. 全局区/静态区：程序开始到程序结束一直都存在，全局变量与静态变量的初始化。在 `main` 函数执行之前执行。
4. 常量区：存放所有的常量，内容不能被修改。强行修改会导致程序崩溃，防止后期造成更大的问题。

堆在低地址（从左到右，向高地址推进），栈在高地址（从右向左，向低地址推进）。然后堆、栈会共享一片区域，增加内存使用效率。

`char* str = "hello world";`，`str`位于栈区，`"hello world"`位于常量区。

`new char[8]`放在堆区。

数组的名字是数组首地址的别名，按照地址访问数组的值：`*(a + 2)`。

# 常量与指针

`const`关键字，尽可能使用。

## 指针

可以是变量也可以是常量，包含两部分：

1. 指针变量本身
2. 指针变量所指向的数据

常量指针：指向常量值的指针变量，指针指向的内容不能通过指针 `*p` 来修改。

指针常量：一个常量，指向变量值的不可变指针，如数组名。

# 宏

`#define` 是一个预处理指示符。如 `#define TRUE 1`，将`TRUE` 替换为 1。

# typedef

`typedef int A`

`using` 代替 `typedef`，`using uint = usigned int;`，`using funcType = void(*) (int, int);`，函数指针类型。然后

```C
void example(int, int){

}
funcType f = example;
```

`using std::cin` 是对象，不是类型。定义模板的别名，只能使用`using`。代表类型的名字必须首字母大写，其他字母大小写混合。

# 局部变量的作用域

作用域是这个块。
```C
for (int i = 0; i < n; i++){
    loop(i);
}
```

## 一元作用域解析运算符`::`

局部变量和全局变量重叠时，使用`::variable`访问全局变量。

# 重载函数

一个函数只能用于特定类型，想用于浮点类型。调用重载函数的时候进行匹配，在编译阶段完成。只匹配参数，不看返回值。但可能会导致二义性。

# 函数参数默认值

```C++
int max(int x, int y{0}){

}
max(1) // 传给 x
```

定义时默认参数值后置；调用时实参前置。

默认参数只能放在函数声明处或者定义处，能放在声明处就放在声明处 。

函数重载时，不允许重定义默认参数。

与重载函数一起使用时，可能会导致二义性。

```C++
int func(int a)
{
    return a;
}

int func(int a, int b = 1)
{
    return a + b;
}
```

# 内联函数

关键字 `inline`。

普通函数的优缺点：

1. 代码块重用，易读易维护
2. 调用和返回时有开销，如临时变量的存储和现场的恢复

内联函数：

1. 减小调用开销
2. 代码插入到调用处，不存在调用传参、返回的开销
3. 导致程序变大，以空间换时间

调用时会内联展开，将内联代码插入到调用处。内联函数的声明和定义一般不分开。

使用限制：

1. 适用：频繁调用的短函数
2. 不适用：多处调用的长函数

是编译机制，是对编译器的请求，而不是强制性命令。尽量进行内联展开，循环、递归、静态变量不会做成内联函数，代码太多也不会内联展开。